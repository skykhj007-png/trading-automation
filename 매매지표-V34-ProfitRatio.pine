//@version=5
strategy("V34 ProfitRatio", overlay=true, max_labels_count=100, max_lines_count=50, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=1000, commission_type=strategy.commission.percent, commission_value=0.1, slippage=2)

// ============================================
// V34 ProfitRatio - 손익비 개선 버전
//
// V33 문제: 손익비 0.21 (TP < SL)
// 해결: TP 확대, SL 타이트, 트레일링
// ============================================

// ============================================
// 거래 모드
// ============================================
tradeMode = input.string("선물", title="거래 모드", options=["선물", "현물코인", "주식"])
shortMode = input.string("항상 OFF", title="SHORT 모드", options=["자동", "항상 OFF", "항상 ON"], group="거래 설정")

// ============================================
// 타임프레임 감지
// ============================================
currentTFMinutes = timeframe.in_seconds() / 60

bool isScalpingTF = currentTFMinutes <= 5
bool isShortTF = currentTFMinutes <= 15
bool isMidTF = currentTFMinutes <= 60

string autoHTF1 = currentTFMinutes <= 1 ? "15" : currentTFMinutes <= 5 ? "60" : currentTFMinutes <= 15 ? "240" : currentTFMinutes <= 60 ? "D" : "W"
string autoHTF2 = currentTFMinutes <= 1 ? "60" : currentTFMinutes <= 5 ? "240" : currentTFMinutes <= 15 ? "D" : currentTFMinutes <= 60 ? "W" : "M"

// ============================================
// HTF 설정
// ============================================
useHTFConfirm = input.bool(true, title="HTF 추세 컨펌", group="HTF 설정")
htfTimeframe1 = input.timeframe("", title="HTF 1 (비우면 자동)", group="HTF 설정")
htfTimeframe2 = input.timeframe("", title="HTF 2 (비우면 자동)", group="HTF 설정")

string finalHTF1 = htfTimeframe1 == "" ? autoHTF1 : htfTimeframe1
string finalHTF2 = htfTimeframe2 == "" ? autoHTF2 : htfTimeframe2

// ============================================
// TP/SL 설정 (손익비 2:1 이상)
// ============================================
leverageInput = input.int(10, title="레버리지", minval=1, maxval=50, step=1, group="TP/SL 설정")
float leverageMultiplier = 5.0 / leverageInput

// TP:SL = 2:1 (TP 크게, SL 타이트)
float autoTP1 = isScalpingTF ? 0.6 : isShortTF ? 0.8 : isMidTF ? 1.2 : 2.0
float autoTP2 = isScalpingTF ? 1.0 : isShortTF ? 1.4 : isMidTF ? 2.0 : 3.5
float autoSL = isScalpingTF ? 0.25 : isShortTF ? 0.35 : isMidTF ? 0.5 : 0.8

float defaultTP1 = tradeMode == "선물" ? autoTP1 * leverageMultiplier : autoTP1
float defaultTP2 = tradeMode == "선물" ? autoTP2 * leverageMultiplier : autoTP2
float defaultSL = tradeMode == "선물" ? autoSL * leverageMultiplier : autoSL

defaultTP1 := math.max(0.3, math.min(defaultTP1, 5.0))
defaultTP2 := math.max(0.5, math.min(defaultTP2, 10.0))
defaultSL := math.max(0.1, math.min(defaultSL, 2.0))

useAutoTPSL = input.bool(true, title="자동 TP/SL", group="TP/SL 설정")
manualTP1 = input.float(0.6, title="수동 TP1 (%)", minval=0.1, maxval=10.0, step=0.05, group="TP/SL 설정")
manualTP2 = input.float(1.0, title="수동 TP2 (%)", minval=0.1, maxval=20.0, step=0.05, group="TP/SL 설정")
manualSL = input.float(0.25, title="수동 SL (%)", minval=0.05, maxval=5.0, step=0.05, group="TP/SL 설정")

float tpPct1 = useAutoTPSL ? defaultTP1 : manualTP1
float tpPct2 = useAutoTPSL ? defaultTP2 : manualTP2
float slPct = useAutoTPSL ? defaultSL : manualSL

// 트레일링 스탑
useTrailing = input.bool(true, title="트레일링 스탑", group="TP/SL 설정")
trailOffset = input.float(0.15, title="트레일 오프셋 (%)", minval=0.05, maxval=1.0, step=0.05, group="TP/SL 설정")

// ============================================
// 신호 설정
// ============================================
int autoMinScore = isScalpingTF ? 16 : isShortTF ? 17 : 18
int autoMinBars = isScalpingTF ? 8 : isShortTF ? 12 : 15

minSignalStrength = input.int(0, title="최소 신호 강도 (0=자동)", minval=0, maxval=24, group="신호 설정")
minBarsBetweenSignals = input.int(0, title="신호 최소 간격 (0=자동)", minval=0, maxval=50, group="신호 설정")

int finalMinScore = minSignalStrength == 0 ? autoMinScore : minSignalStrength
int finalMinBars = minBarsBetweenSignals == 0 ? autoMinBars : minBarsBetweenSignals

// ============================================
// ADX 설정
// ============================================
useADXFilter = input.bool(true, title="ADX 필터", group="ADX 설정")
adxLength = input.int(14, title="ADX 길이", group="ADX 설정")
adxThreshold = input.float(22.0, title="ADX 임계값", minval=15.0, maxval=35.0, step=1.0, group="ADX 설정")

// ============================================
// 현재 타임프레임 지표
// ============================================
ema9 = ta.ema(close, 9)
ema21 = ta.ema(close, 21)
ema50 = ta.ema(close, 50)
ema200 = ta.ema(close, 200)

// 추세 (매우 엄격)
bool emaAlignedUp = ema9 > ema21 and ema21 > ema50
bool emaAlignedDown = ema9 < ema21 and ema21 < ema50
bool strongUptrend = emaAlignedUp and close > ema50 and close > ema200 and close > close[5]
bool strongDowntrend = emaAlignedDown and close < ema50 and close < ema200 and close < close[5]
bool isUptrend = ema9 > ema21 and close > ema21 and close > close[2]
bool isDowntrend = ema9 < ema21 and close < ema21 and close < close[2]
bool aboveEMA200 = close > ema200
bool belowEMA200 = close < ema200

// 추세 초기 감지 (진입 타이밍 개선)
bool trendJustStarted = ta.crossover(ema9, ema21) and close > ema50
bool downTrendJustStarted = ta.crossunder(ema9, ema21) and close < ema50

// ADX/DMI
[diPlus, diMinus, adxValue] = ta.dmi(adxLength, adxLength)
bool trendExists = adxValue >= adxThreshold
bool strongTrend = adxValue >= 28
bool bullishDI = diPlus > diMinus
bool bearishDI = diMinus > diPlus
bool diCrossUp = ta.crossover(diPlus, diMinus)
bool diCrossDown = ta.crossunder(diPlus, diMinus)

// RSI
rsi = ta.rsi(close, 14)
bool rsiOversold = rsi < 35
bool rsiOverbought = rsi > 65
bool rsiBullZone = rsi > 45 and rsi < 65
bool rsiBearZone = rsi > 35 and rsi < 55
bool rsiRising = rsi > rsi[1] and rsi > rsi[2] and rsi > rsi[3]
bool rsiFalling = rsi < rsi[1] and rsi < rsi[2] and rsi < rsi[3]

// Stochastic RSI
stochRsi = ta.stoch(rsi, rsi, rsi, 14)
stochK = ta.sma(stochRsi, 3)
stochD = ta.sma(stochK, 3)
bool stochOversold = stochK < 25
bool stochOverbought = stochK > 75
bool stochGoldenCross = ta.crossover(stochK, stochD) and stochK < 35
bool stochDeadCross = ta.crossunder(stochK, stochD) and stochK > 65
bool stochBullish = stochK > stochD and stochK < 70
bool stochBearish = stochK < stochD and stochK > 30
bool stochRising = stochK > stochK[1] and stochK > stochK[2]

// MACD
[macdLine, signalLine, histogram] = ta.macd(close, 12, 26, 9)
bool macdBullish = macdLine > signalLine and histogram > 0
bool macdBearish = macdLine < signalLine and histogram < 0
bool macdCrossUp = ta.crossover(macdLine, signalLine)
bool macdCrossDown = ta.crossunder(macdLine, signalLine)
bool macdRising = histogram > histogram[1] and histogram > histogram[2]
bool macdFalling = histogram < histogram[1] and histogram < histogram[2]
bool macdAboveZero = macdLine > 0

// Bollinger Bands
bbBasis = ta.sma(close, 20)
bbDev = ta.stdev(close, 20)
bbUpper = bbBasis + 2 * bbDev
bbLower = bbBasis - 2 * bbDev
bool nearBBLower = low <= bbLower * 1.005
bool nearBBUpper = high >= bbUpper * 0.995
bool priceAboveBB = close > bbBasis

// Volume
avgVolume = ta.sma(volume, 20)
volumeRatio = volume / avgVolume
bool volumeConfirm = volumeRatio >= 1.3
bool highVolume = volumeRatio >= 1.8
bool veryHighVolume = volumeRatio >= 2.5

bullVolume = close > open ? volume : volume * (close - low) / math.max(high - low, 0.0001)
bearVolume = close < open ? volume : volume * (high - close) / math.max(high - low, 0.0001)
buyPressure = bullVolume / (bullVolume + bearVolume) * 100
bool strongBuyPressure = buyPressure > 62
bool strongSellPressure = buyPressure < 38

// Candle patterns
bodySize = math.abs(close - open)
lowerWick = math.min(close, open) - low
upperWick = high - math.max(close, open)
avgBody = ta.sma(bodySize, 14)

bool strongBullCandle = close > open and bodySize > avgBody * 1.3 and close > high[1]
bool strongBearCandle = close < open and bodySize > avgBody * 1.3 and close < low[1]
bool isHammer = lowerWick > bodySize * 2.5 and upperWick < bodySize * 0.3 and close > open
bool consecutiveBullish = close > open and close[1] > open[1] and close[2] > open[2]

// ============================================
// HTF 데이터
// ============================================
[htf1_close, htf1_ema9, htf1_ema21, htf1_rsi] = request.security(syminfo.tickerid, finalHTF1, [close, ta.ema(close, 9), ta.ema(close, 21), ta.rsi(close, 14)], lookahead=barmerge.lookahead_off)
[htf1_macdLine, htf1_signalLine] = request.security(syminfo.tickerid, finalHTF1, [ta.ema(close, 12) - ta.ema(close, 26), ta.ema(ta.ema(close, 12) - ta.ema(close, 26), 9)], lookahead=barmerge.lookahead_off)

bool htf1_uptrend = htf1_ema9 > htf1_ema21 and htf1_close > htf1_ema21
bool htf1_downtrend = htf1_ema9 < htf1_ema21 and htf1_close < htf1_ema21
bool htf1_bullish = htf1_uptrend and htf1_rsi > 48 and htf1_rsi < 72 and htf1_macdLine > htf1_signalLine
bool htf1_bearish = htf1_downtrend and htf1_rsi > 28 and htf1_rsi < 52 and htf1_macdLine < htf1_signalLine

[htf2_close, htf2_ema9, htf2_ema21, htf2_rsi] = request.security(syminfo.tickerid, finalHTF2, [close, ta.ema(close, 9), ta.ema(close, 21), ta.rsi(close, 14)], lookahead=barmerge.lookahead_off)
[htf2_macdLine, htf2_signalLine] = request.security(syminfo.tickerid, finalHTF2, [ta.ema(close, 12) - ta.ema(close, 26), ta.ema(ta.ema(close, 12) - ta.ema(close, 26), 9)], lookahead=barmerge.lookahead_off)

bool htf2_uptrend = htf2_ema9 > htf2_ema21 and htf2_close > htf2_ema21
bool htf2_downtrend = htf2_ema9 < htf2_ema21 and htf2_close < htf2_ema21
bool htf2_bullish = htf2_uptrend and htf2_rsi > 48 and htf2_rsi < 72 and htf2_macdLine > htf2_signalLine
bool htf2_bearish = htf2_downtrend and htf2_rsi > 28 and htf2_rsi < 52 and htf2_macdLine < htf2_signalLine

bool htfBothBullish = htf1_bullish and htf2_bullish
bool htfBothBearish = htf1_bearish and htf2_bearish
bool htfAtLeastOneBullish = htf1_bullish or htf2_bullish

// ============================================
// 신호 간격
// ============================================
var int barsSinceLastLong = 999
var int barsSinceLastShort = 999
barsSinceLastLong := barsSinceLastLong + 1
barsSinceLastShort := barsSinceLastShort + 1
bool canSignalLong = barsSinceLastLong >= finalMinBars
bool canSignalShort = barsSinceLastShort >= finalMinBars

// ============================================
// 점수 시스템 (최대 26점)
// ============================================

// LONG 점수
float trendScore = strongUptrend ? 6 : isUptrend ? 4 : emaAlignedUp ? 2 : 0
trendScore += aboveEMA200 ? 2 : 0
trendScore += htf1_bullish ? 2 : htf1_uptrend ? 1 : 0
trendScore += htf2_bullish ? 2 : htf2_uptrend ? 1 : 0
trendScore += trendJustStarted ? 2 : 0  // 추세 초기 보너스

float momentumScore = stochGoldenCross ? 3 : (stochOversold and stochRising) ? 2 : stochBullish ? 1 : 0
momentumScore += macdCrossUp ? 3 : (macdBullish and macdRising and macdAboveZero) ? 2 : macdBullish ? 1 : 0
momentumScore += (rsiBullZone and rsiRising) ? 2 : rsiBullZone ? 1 : 0
momentumScore += (diCrossUp and trendExists) ? 2 : (bullishDI and strongTrend) ? 2 : (bullishDI and trendExists) ? 1 : 0

float confirmScore = (veryHighVolume and strongBuyPressure) ? 3 : (highVolume and strongBuyPressure) ? 2 : volumeConfirm ? 1 : 0
confirmScore += nearBBLower and stochOversold ? 2 : nearBBLower ? 1 : 0
confirmScore += (isHammer or strongBullCandle) ? 2 : consecutiveBullish ? 1 : 0

float totalScore = trendScore + momentumScore + confirmScore

// SHORT 점수
float trendScoreShort = strongDowntrend ? 6 : isDowntrend ? 4 : emaAlignedDown ? 2 : 0
trendScoreShort += belowEMA200 ? 2 : 0
trendScoreShort += htf1_bearish ? 2 : htf1_downtrend ? 1 : 0
trendScoreShort += htf2_bearish ? 2 : htf2_downtrend ? 1 : 0
trendScoreShort += downTrendJustStarted ? 2 : 0

float momentumScoreShort = stochDeadCross ? 3 : (stochOverbought and stochBearish) ? 2 : stochBearish ? 1 : 0
momentumScoreShort += macdCrossDown ? 3 : (macdBearish and macdFalling) ? 2 : macdBearish ? 1 : 0
momentumScoreShort += (rsiBearZone and rsiFalling) ? 2 : rsiBearZone ? 1 : 0
momentumScoreShort += (diCrossDown and trendExists) ? 2 : (bearishDI and strongTrend) ? 2 : (bearishDI and trendExists) ? 1 : 0

float confirmScoreShort = (veryHighVolume and strongSellPressure) ? 3 : (highVolume and strongSellPressure) ? 2 : volumeConfirm ? 1 : 0
confirmScoreShort += nearBBUpper and stochOverbought ? 2 : nearBBUpper ? 1 : 0
confirmScoreShort += strongBearCandle ? 2 : 0

float totalScoreShort = trendScoreShort + momentumScoreShort + confirmScoreShort

// ============================================
// 신호 조건 (진입 타이밍 최적화)
// ============================================

// LONG - 추세 초기 또는 풀백 후 재진입
bool trendOK = strongUptrend or (isUptrend and priceAboveBB)
bool htfOK = useHTFConfirm ? htfAtLeastOneBullish : true
bool momentumOK = (stochBullish or stochGoldenCross) and (macdBullish or macdCrossUp)
bool pullbackEntry = isUptrend and stochOversold and rsiRising  // 풀백 후 진입

bool longBase = totalScore >= finalMinScore
longBase := longBase and canSignalLong
longBase := longBase and (trendOK or pullbackEntry or trendJustStarted)
longBase := longBase and htfOK
longBase := longBase and (momentumOK or trendJustStarted)
longBase := useADXFilter ? longBase and trendExists and bullishDI : longBase
longBase := longBase and volumeConfirm

bool longSignal_final = longBase

// SHORT
var bool enableShort = false
enableShort := tradeMode == "선물" ? (shortMode == "항상 ON" ? true : shortMode == "자동" ? htfBothBearish : false) : false

bool shortBase = enableShort and totalScoreShort >= finalMinScore
shortBase := shortBase and canSignalShort
shortBase := shortBase and (strongDowntrend or downTrendJustStarted)
shortBase := shortBase and htfBothBearish
shortBase := useADXFilter ? shortBase and trendExists and bearishDI : shortBase
shortBase := shortBase and volumeConfirm

bool shortSignal_final = shortBase

if longSignal_final
    barsSinceLastLong := 0
if shortSignal_final
    barsSinceLastShort := 0

// ============================================
// Strategy (트레일링 스탑 포함)
// ============================================
if longSignal_final and strategy.position_size == 0
    strategy.entry("LONG", strategy.long)

if shortSignal_final and strategy.position_size == 0
    strategy.entry("SHORT", strategy.short)

// LONG 청산
if strategy.position_size > 0
    float tp1 = strategy.position_avg_price * (1 + tpPct1/100)
    float tp2 = strategy.position_avg_price * (1 + tpPct2/100)
    float sl = strategy.position_avg_price * (1 - slPct/100)

    if useTrailing
        float trailPrice = strategy.position_avg_price * (1 + trailOffset/100)
        strategy.exit("TP1", "LONG", qty_percent=50, limit=tp1, stop=sl, trail_price=trailPrice, trail_offset=trailOffset * close / 100)
        strategy.exit("TP2", "LONG", limit=tp2, stop=sl, trail_price=trailPrice, trail_offset=trailOffset * close / 100)
    else
        strategy.exit("TP1", "LONG", qty_percent=50, limit=tp1, stop=sl)
        strategy.exit("TP2", "LONG", limit=tp2, stop=sl)

// SHORT 청산
if strategy.position_size < 0
    float sTP1 = strategy.position_avg_price * (1 - tpPct1/100)
    float sTP2 = strategy.position_avg_price * (1 - tpPct2/100)
    float sSL = strategy.position_avg_price * (1 + slPct/100)

    if useTrailing
        float sTrailPrice = strategy.position_avg_price * (1 - trailOffset/100)
        strategy.exit("TP1", "SHORT", qty_percent=50, limit=sTP1, stop=sSL, trail_price=sTrailPrice, trail_offset=trailOffset * close / 100)
        strategy.exit("TP2", "SHORT", limit=sTP2, stop=sSL, trail_price=sTrailPrice, trail_offset=trailOffset * close / 100)
    else
        strategy.exit("TP1", "SHORT", qty_percent=50, limit=sTP1, stop=sSL)
        strategy.exit("TP2", "SHORT", limit=sTP2, stop=sSL)

// ============================================
// Chart
// ============================================
plot(ema9, color=color.new(color.yellow, 50), linewidth=1, title="EMA 9")
plot(ema21, color=color.new(color.orange, 0), linewidth=2, title="EMA 21")
plot(ema50, color=color.new(color.blue, 0), linewidth=2, title="EMA 50")
plot(ema200, color=color.new(color.purple, 50), linewidth=1, title="EMA 200")

plotshape(longSignal_final, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title="LONG")
plotshape(shortSignal_final, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="SHORT")

bgcolor(strongUptrend ? color.new(color.green, 94) : strongDowntrend ? color.new(color.red, 94) : na)

// Labels
if longSignal_final
    label.new(bar_index, low, "L" + str.tostring(totalScore, "#"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.tiny)

if shortSignal_final
    label.new(bar_index, high, "S" + str.tostring(totalScoreShort, "#"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.tiny)

// ============================================
// Info Table
// ============================================
var table infoTable = table.new(position.top_right, 2, 9, bgcolor=color.new(color.white, 10), border_width=1)

string tfInfo = str.tostring(currentTFMinutes) + "m"
string htf1_status = htf1_bullish ? "B" : htf1_bearish ? "S" : htf1_uptrend ? "b" : htf1_downtrend ? "s" : "-"
string htf2_status = htf2_bullish ? "B" : htf2_bearish ? "S" : htf2_uptrend ? "b" : htf2_downtrend ? "s" : "-"
string trendStatus = strongUptrend ? "UP" : strongDowntrend ? "DN" : isUptrend ? "up" : isDowntrend ? "dn" : "-"
string finalText = longSignal_final ? "LONG" : shortSignal_final ? "SHORT" : "WAIT"
color finalColor = longSignal_final ? color.green : shortSignal_final ? color.red : color.gray

if barstate.islast
    table.clear(infoTable, 0, 0, 1, 8)
    table.cell(infoTable, 0, 0, "V34 Profit", text_color=color.white, text_size=size.small, bgcolor=color.new(color.teal, 20))
    table.cell(infoTable, 1, 0, tfInfo + " " + str.tostring(leverageInput) + "x", text_color=color.white, text_size=size.small, bgcolor=color.new(color.teal, 20))
    table.cell(infoTable, 0, 1, "Score", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 1, str.tostring(totalScore, "#.#") + "/" + str.tostring(finalMinScore), text_color=totalScore >= finalMinScore ? color.green : color.gray, text_size=size.tiny)
    table.cell(infoTable, 0, 2, "HTF", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 2, finalHTF1 + ":" + htf1_status + " " + finalHTF2 + ":" + htf2_status, text_color=htf1_bullish or htf2_bullish ? color.green : htf1_bearish or htf2_bearish ? color.red : color.gray, text_size=size.tiny)
    table.cell(infoTable, 0, 3, "Trend", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 3, trendStatus + " ADX:" + str.tostring(adxValue, "#"), text_color=trendExists and bullishDI ? color.green : trendExists and bearishDI ? color.red : color.gray, text_size=size.tiny)
    table.cell(infoTable, 0, 4, "RSI/K", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 4, str.tostring(rsi, "#") + "/" + str.tostring(stochK, "#"), text_color=stochOversold ? color.green : stochOverbought ? color.red : color.gray, text_size=size.tiny)
    table.cell(infoTable, 0, 5, "Vol", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 5, str.tostring(volumeRatio, "#.#") + "x", text_color=highVolume ? color.green : color.gray, text_size=size.tiny)
    table.cell(infoTable, 0, 6, "TP/SL", text_color=color.black, text_size=size.tiny)
    table.cell(infoTable, 1, 6, str.tostring(tpPct1, "#.##") + "/" + str.tostring(slPct, "#.##") + "% (2:1)", text_color=color.blue, text_size=size.tiny)
    table.cell(infoTable, 0, 7, "SIGNAL", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(infoTable, 1, 7, finalText, text_color=finalColor, text_size=size.tiny, bgcolor=color.new(color.gray, 30))

// ============================================
// Alerts
// ============================================
float longTP1Price = close * (1 + tpPct1/100)
float longTP2Price = close * (1 + tpPct2/100)
float longSLPrice = close * (1 - slPct/100)

if longSignal_final
    string longAlert = "LONG " + syminfo.basecurrency + "/USDT\n" + "━━━━━━━━━━━━━━━━\n" + tfInfo + " | Score: " + str.tostring(totalScore, "#") + "/" + str.tostring(finalMinScore) + " | " + str.tostring(leverageInput) + "x\n" + "HTF: " + finalHTF1 + "(" + htf1_status + ") " + finalHTF2 + "(" + htf2_status + ")\n" + "━━━━━━━━━━━━━━━━\n" + "Entry: $" + str.tostring(close, "#.##") + "\n\n" + "TP1: $" + str.tostring(longTP1Price, "#.##") + " (+" + str.tostring(tpPct1, "#.##") + "%)\n" + "TP2: $" + str.tostring(longTP2Price, "#.##") + " (+" + str.tostring(tpPct2, "#.##") + "%)\n" + "SL: $" + str.tostring(longSLPrice, "#.##") + " (-" + str.tostring(slPct, "#.##") + "%)\n" + "━━━━━━━━━━━━━━━━\n" + "R:R = 1:" + str.tostring(tpPct1/slPct, "#.#")
    alert(longAlert, freq=alert.freq_once_per_bar)

if shortSignal_final
    float shortTP1Price = close * (1 - tpPct1/100)
    float shortTP2Price = close * (1 - tpPct2/100)
    float shortSLPrice = close * (1 + slPct/100)
    string shortAlert = "SHORT " + syminfo.basecurrency + "/USDT\n" + "━━━━━━━━━━━━━━━━\n" + tfInfo + " | Score: " + str.tostring(totalScoreShort, "#") + "/" + str.tostring(finalMinScore) + " | " + str.tostring(leverageInput) + "x\n" + "HTF: " + finalHTF1 + "(" + htf1_status + ") " + finalHTF2 + "(" + htf2_status + ")\n" + "━━━━━━━━━━━━━━━━\n" + "Entry: $" + str.tostring(close, "#.##") + "\n\n" + "TP1: $" + str.tostring(shortTP1Price, "#.##") + " (-" + str.tostring(tpPct1, "#.##") + "%)\n" + "TP2: $" + str.tostring(shortTP2Price, "#.##") + " (-" + str.tostring(tpPct2, "#.##") + "%)\n" + "SL: $" + str.tostring(shortSLPrice, "#.##") + " (+" + str.tostring(slPct, "#.##") + "%)\n" + "━━━━━━━━━━━━━━━━\n" + "R:R = 1:" + str.tostring(tpPct1/slPct, "#.#")
    alert(shortAlert, freq=alert.freq_once_per_bar)
